#!/usr/bin/env bash

# Copy/link this file somewhere inside your path
# This is the bash machinery to power docker builds, deployments and image/container manipulation for various edw projects.
# This file holds all the logic save for extendable specific bits that located in each project build/deploy repo
# and are meant to be sourced inside this file


##  Init

case $TERM in
    *xterm*)
        color_prompt=yes
        # mac's bash (3.x) does not have fall through '&;' :-(
        ;;
    *color*)
        color_prompt=yes
        ;;
    *)
        color_prompt=no
        ;;
esac

if [ "$color_prompt" = yes ]; then
    White="[m[K"
    Red="[0;31m[K"
    Green="[0;32m[K"
    Yellow="[0;33mK"
    Blue="[0;34mK"
else
    White=
    Red=
    Green=
    Yellow=
    Blue=
fi
True=0
False=1

export g_env_file=.env


## Helper functions

_edw_set_env() {
    while read -r ln; do
        [[ -z "$ln" || "$ln" == \#* ]] || export $ln
    done < $1
}

_edw_get_index() {
    local value=$1
    shift
    # pass the rest of array as arguments to this function
    local arr=($*)
    local indexes=${!arr[@]}

    for i in ${indexes[@]}; do
        if [[ ${arr[$i]} = $value ]]; then
            echo $i
            return $True
        fi
    done
    return $False
}

_edw_resolve_interpolated_var() {
    local name="EDW_${1}${2}"
    eval res=\$$name
    echo $res
}

_edw_bail_out_if_error() {
    local verbose="$1"
    if [ "$?" != 0 ]; then
        if [ -n "$verbose" ]; then
            echo "${Red}Somehing went wrong!${Yellow}Please manually investigate ${Green}${EDW_DEPLOY_HOST}${White}"
        fi
        exit 1
    fi
}
_edw_show_run_context() {
    OPTIND=1
    local confirmation=

    echo -e "${Yellow}=======================================================${White}\n"
    echo "Building in dir: `pwd`"

    #
    # -e show environment
    # -d show deploy manifest
    # -s show command specific info
    # -y don't ask for confirmation; assume confirmation
    while getopts ":edys" opt; do
        case "$opt" in
            e)
                echo -e "\n${Yellow}Running eviroment vars:${White}"
                env |grep -e'^EDW_'
                ;;
            d)
                echo -e "\n${Yellow}Using files manifested in deploy.manifest:"
                echo -e " (Make sure these files exist relative to current directory and contain proper configuration)${White}"
                cat deploy.manifest
                ;;
            s)
                echo -e "\n${Yellow}Command specific context:${White}"
                _edw_command_specific_show_run_context
                ;;
            y)
                confirmation=y
                ;;
            ?)
                echo "Invalid option: -$OPTARG" >&2
                _edw_help
                exit 1
                ;;
            :)
                echo "Option -$OPTARG requires an argument." >&2
                _edw_help
                exit 1
                ;;
        esac
    done

    echo -e "\n${Yellow}=======================================================${White}"
    echo

    if [ -z "$confirmation" ]; then
        echo "${Yellow}Are you sure you want to proceed? (y/n)${White}"
        read confirmation
    fi

    if [ "$confirmation" != "y" -a "$confirmation" != "Y" ]; then
        return $False
    else
        return $True
    fi
}

_edw_full_docker_image() {
    local repo=$EDW_BUILD_DOCKERHUB
    local tag=$EDW_BUILD_VER

    OPTIND=1
    while getopts ":r:t:" opt; do
        case "$opt" in
            r)
                repo=$OPTARG
                ;;
            t)
                tag=$OPTARG
                ;;
            ?)
                echo "Invalid option: -$OPTARG" >&2
                _edw_help
                exit 1
                ;;
            :)
                echo "Option -$OPTARG requires an argument." >&2
                _edw_help
                exit 1
                ;;
        esac
    done
    shift $((OPTIND-1))
    local name=$1
    [ -z "$name" ] && echo "Give a subproject base name to form the docker image name" >&2

    echo -n ${repo}/${EDW_DEPLOY_PROJECT}_${name}:${tag}
}

_edw_projects_images() {
    # init output vars
    local docker_only=${1:-true}
    # reset array; this is the array from whatever instance of bash is calling this in its own bash context
    arr_docker_images=()

    cd build
    for dir in $(find * -maxdepth 0 -type d -print); do
        if [ -n "$dir" ]; then
            if [ $docker_only = false -o -f $dir/Dockerfile ]; then
                arr_docker_images+=("$dir")
            fi
        fi
    done
    cd - >/dev/null
}

## Commands

_edw_help() {
    echo -e "Docker wrapper for various edw projects"
    echo -e "This util will run docker images build, deploy, start and maintenace scripts"
    echo -e "taking into consideration the variables from the current directory"
    echo -e "Usage: edwd [options] command [command options]"
    echo -e "\t-e <env file>:  Source env vars from this file into edwd machinery; default is .env; don't export the vars, they are meant to live only inside this script."
    echo -e "\tOther options"
    echo -e "\t-h:  Show this help"
}

_edw_commands() {
    echo "
build"
}


# this function will start its own shell;
# Thus it will not overwrite parent functions and definitios
_edw_build_caged() (
    OPTIND=1

    _edw_help() {
        echo -e "Build a docker image based on current repo dir and variables present in current environment and files in deploy.manifest"
        echo -e "Usage:"
        echo -e "\t-g branch:  git branch/tag to clone before build; Default is master;"
        echo -e "\t\t EDW_<proj_name>_SRC var can override clonnig and the src files from a local directory"
        echo -e "\t-t tag:  tag to push in git AND to create docker image with; Default is env \$EDW_BUILD_VER"
        echo -e "\t-p projects:  Build only the following comma separated (no space) list of projects."
        echo -e "\t-n:  no-push, Do not create git tag AND do not push image to docker.hub; Default is false"
        echo -e "\tOther options"
        echo -e "\t-y:  confirmed; Do not ask for user confirmation from stdin; Default is false"
        echo -e "\t-q:  quiet mode; Do not output on stdout; Assume -y; Default is false"
        echo -e "\t-h:  help; Display this message"
}
    
    git_checkout=master
    tag=$EDW_BUILD_VER
    no_push=false
    quiet=false
    confirmation=
    arr_docker_images=()

    while getopts ":hqyng:t:p:" opt; do
        case "$opt" in
            g)
                git_checkout=$OPTARG
                ;;
            t)
                tag=$OPTARG
                ;;
            p)
                IFS=',' read -a arr_docker_images <<<$OPTARG
                ;;
            n)
                no_push=true
                ;;
            q)
                quiet=true
                confirmation=-y
                ;;
            y)
                confirmation=-y
                ;;
            h)
                _edw_help
                exit 0
                ;;
            ?)
                echo "Invalid option: -$OPTARG" >&2
                _edw_help
                exit 1
                ;;
            :)
                echo "Option -$OPTARG requires an argument." >&2
                _edw_help
                exit 1
                ;;
        esac
    done

    shift $((OPTIND-1))

    # only if array not already filled; check only for the presence of first element
    if [ -z $arr_docker_images ]; then
        _edw_projects_images
    fi

    # define this before calling _edw_show_run_context
    _edw_command_specific_show_run_context() {
        if [ "$no_push" = false ]; then
            echo "We shall ${Red}push tags${White} to git and docker.hub (${Yellow}${tag}${White})"
        else
            echo "We shall ${Red}NOT push tags${White} to git and docker.hub (${Yellow}${tag}${White})"
        fi
        echo "Building based on git branch/tag: ${Yellow}${git_checkout}${White}. EDW_<proj_name>_SRC might override this"
        echo "Building projects ${Green}${arr_docker_images[@]}${White}"
        for proj in "${arr_docker_images[@]}"; do
            local src_dir=`_edw_get_src_dir $proj`
            local repo=`_edw_get_src_repo $proj`
            if [ -n "$src_dir" ]; then
                echo -n "Building ${Green}${proj}${White} from local dir ${Yellow}${src_dir}${White}"
            elif [ -n "$repo" ]; then
                echo -n "Building ${Green}${proj}${White} from git ${Yellow}${repo}${White}"
            else
                echo -n "Building ${Green}${proj}${White} (no source required/specified)"
            fi
            echo " into image: ${Yellow}`_edw_full_docker_image -t $tag $proj`${White}"

        done
    }

    _edw_get_src_dir() {
        local proj=$1
        local src_dir=`_edw_resolve_interpolated_var $proj _SRC`
        echo $src_dir
    }

    _edw_get_src_repo() {
        local proj=$1
        local repo=
        if [ -f build/${proj}/src.url ]; then
            read repo <build/${proj}/src.url
        fi
        echo $repo
    }

    _edw_copy_local_src() {
        local src=$1
        local dest=$2
        for f in `ls -a $src/`; do
            [ "$f" = .git -o "$f" = . -o "$f" = .. ] && continue
            # TODO what to do with symlinks? copy them as are and let docker daemon default behaviour kick in 
            cp -R $src/$f $dest/
        done
    }
    
    go_on=$False
    if [ "$quiet" = false ]; then
        _edw_show_run_context -es "$confirmation"
        go_on=$?
    else
        go_on=$True
    fi
    [ $go_on = $False ] && exit 0

    # TODO veryfy this on windows
    tmp_name=edwd.${PPID}.$$.${RANDOM}
    mkdir -p $tmp_name
    # for each project - build docker image
    for proj in "${arr_docker_images[@]}"; do
        # get source dir and repo to clone; local_src_dir has priority
        local_src_dir=`_edw_get_src_dir $proj`
        src_dir=
        docker_src_dir=
        repo=`_edw_get_src_repo $proj`
        build_args=()

        # we have a local source dir
        if [ -n "$local_src_dir" ]; then
            local new_src_dir=$tmp_name/$proj
            mkdir $new_src_dir
            _edw_copy_local_src "$local_src_dir" $new_src_dir
            src_dir=$new_src_dir
        # we have a repo and not a local source dir overrinding it
        elif [ -n "$repo" ]; then
            cd $tmp_name
            git clone --depth 1 --branch ${git_checkout} --single-branch $repo $proj &&\
                src_dir=${tmp_name}/${proj}
            cd - >/dev/null
        fi

        if [ -n "$src_dir" ]; then
            build_args+=("--build-arg EDW_SRC_DIR=$src_dir")
        fi
        # add build specific vars
        for v in `grep EDW_${proj}_ $g_env_file`; do
            build_args+=("--build-arg $v")
        done

        if [ $quiet = false ]; then
            echo
            echo -n "[ ${Green}${proj}${White} ] "
            echo "docker build -t `_edw_full_docker_image -t $tag $proj` ${build_args[@]} -f build/$proj/Dockerfile ."
        fi
        docker build -t `_edw_full_docker_image -t $tag $proj` ${build_args[@]} -f build/$proj/Dockerfile .
        # This will not be pushed, but used locally by other images that depend on this one
        docker rmi `_edw_full_docker_image -t latest $proj` 2>/dev/null
        docker tag `_edw_full_docker_image -t $tag $proj` `_edw_full_docker_image -t latest $proj`

        if [ $no_push = false ]; then
            docker push `_edw_full_docker_image -t $tag $proj`
            _edw_bail_out_if_error
            if [ -n "$src_dir" ]; then
                if [ -n "$local_src_dir" ]; then
                    cd $local_src_dir
                else
                    # assert [ -n "$repo" ]
                    cd $src_dir
                fi
                # TODO namespace for git tags? project-name_$tag? docker-repo_$tag?
                git tag $tag && git push origin $tag
                cd -
            fi
        fi

    done

    if [ -d "$tmp_name" ]; then
        rm -rf $tmp_name
    fi
    
)

_edw_deploy_caged() (
    OPTIND=1

    _edw_help() {
        echo -e "Deploy project based own images from docker.hub and deployment files from this directory"
        echo -e "\tUsage:"
        echo -e "\t-t tag:  images tag to pull from docker.hub or use locally; Default is \$EDW_BUILD_VER"
        echo -e "\t-p projects:  Build only the following comma separated list (no space) of projects."
        echo -e "\t-n:  no-pull, Do not pull images from docker.hub; assume they are present locally; Default is false"
        echo -e "\t-s:  no-start, Don't start docker suite after deploy. Use if you want to do additional housekeeping right after deploy. Default is false."
        echo -e "\t-f:  force, Do deploy even if lock_deploy file is present in target dir. Default is false"
        echo -e "\t-o:  own, Do deploy even on own machine. Default is false"
        echo -e "\tOther options"
        echo -e "\t-y:  confirmed; Do not ask for user confirmation from stdin; Default is false"
        echo -e "\t-q:  quiet mode; Do not output on stdout; Assume -y; Default is false"
        echo -e "\t-h:  help; Display this message"
    }

    tag=$EDW_BUILD_VER
    no_pull=false
    quiet=false
    confirmation=
    disregard_deploy_lock=false
    no_start=false
    own_machine_deploy=false
    arr_docker_images=()


    while getopts ":hqynsfot:p:" opt; do
        case "$opt" in
            t)
                tag=$OPTARG
                ;;
            p)
                IFS=',' read -a arr_docker_images <<<$OPTARG
                ;;
            n)
                no_pull=true
                ;;
            s)
                no_start=true
                ;;
            f)
                disregard_deploy_lock=true
                ;;
            o)
                own_machine_deploy=true
                ;;
            q)
                quiet=true
                confirmation=-y
                ;;
            y)
                confirmation=-y
                ;;
            h)
                _edw_help
                exit 0
                ;;
            ?)
                echo "Invalid option: -$OPTARG" >&2
                _edw_help
                exit 1
                ;;
            :)
                echo "Option -$OPTARG requires an argument." >&2
                _edw_help
                exit 1
                ;;
        esac
    done

    shift $((OPTIND-1))

    if [ -z $arr_docker_images ]; then
        _edw_projects_images
    fi

    # define this before calling _edw_show_run_context
    _edw_command_specific_show_run_context() {
        if [ "$no_pull" = false ]; then
            echo "${Yellow}We shall pull images from docker.hub ($tag)${White}"
        else
            echo "${Yellow}We shall NOT pull images from docker.hub ${White}"
        fi

        if [ "$disregard_deploy_lock" = true ]; then
            echo "${Red}We shall force deploy disregarding lock_deploy${White}"
        fi

        if [ "$no_start" = true ]; then
            echo "${Red}We shall NOT restart docker-compose suite after deploy${White}"
        else
            echo "${Yellow}We shall restart docker-compose suite after deploy${White}"
        fi
        # TODO we did not include projects without our own image in here...
        echo "Deploying projects ${Green}${arr_docker_images[@]}${White}"

        if [ "$EDW_DEPLOY_HOST" = localhost ]; then
            if [ $own_machine_deploy = false ]; then
                echo "${Green}Deploy target is own machine. Skipping deploy.${White}"
            else
                echo "${Yellow}Deploying on own machine${White}"
            fi
        fi
        local current_ver=`ssh -q -t $EDW_DEPLOY_USER@$EDW_DEPLOY_HOST "cd $EDW_DEPLOY_DIR 2>/dev/null &&\
            [ -f current_tag ] && cat current_tag
            "`
        if [ -n "$current_ver" ];then
            echo "Current version on ${Yellow}${EDW_DEPLOY_HOST}:${EDW_DEPLOY_DIR}${White} is: ${Yellow}${current_ver}${White}"
        fi
    }

    go_on=$False
    if [ "$quiet" = false ]; then
        _edw_show_run_context -eds "$confirmation"
        go_on=$?
    else
        go_on=$True
    fi
    [ $go_on = $False ] && exit 0
    if [ "$EDW_DEPLOY_HOST" = localhost -a $own_machine_deploy = false ]; then
        exit 0
    fi


    # create deploy folder if it does not exist. We assume this is inside EDW_DEPLOY_USER path
    ssh -q -t $EDW_DEPLOY_USER@$EDW_DEPLOY_HOST "cd $EDW_DEPLOY_DIR 2>/dev/null || mkdir -p $EDW_DEPLOY_DIR"
    _edw_bail_out_if_error

    if [ "$disregard_deploy_lock" = false ]; then
        ssh -q -t $EDW_DEPLOY_USER@$EDW_DEPLOY_HOST "cd $EDW_DEPLOY_DIR && [ -f lock_deploy ] && cat lock_deploy && exit 100"
        if [ "$?" = 100 ]; then
            echo "Stopping deployment due to lock_deploy in $EDW_DEPLOY_HOST:$EDW_DEPLOY_DIR"
            exit 1
        fi
    fi

    ssh -q -t $EDW_DEPLOY_USER@$EDW_DEPLOY_HOST "cd $EDW_DEPLOY_DIR && { \
        if [ -f current_tag ]; then \
            [ -f lock_deploy ] && rm lock_deploy ;\
            EDW_BUILD_VER=$EDW_BUILD_VER docker-compose stop 2>/dev/null ;\
            if [ $no_pull = false ]; then \
                EDW_BUILD_VER=$EDW_BUILD_VER docker-compose rm -f -a -v ;\
            fi ;\
        fi ;\
        }"

    for f in `cat deploy.manifest`; do
        local dir=`dirname $f`
        [ -f "$f" ] || exit 1
        ssh -q -t $EDW_DEPLOY_USER@$EDW_DEPLOY_HOST "cd $EDW_DEPLOY_DIR && [ -d "$dir" ] || mkdir -p $dir"
        scp $f $EDW_DEPLOY_USER@$EDW_DEPLOY_HOST:$EDW_DEPLOY_DIR/$f
        _edw_bail_out_if_error
    done

    # add the env vars we've been using. remeber to update whatever was overriden by the command line
    # Do this even if no-pull was used - we are to deploy config to the host even if we don't pull
    scp $g_env_file $EDW_DEPLOY_USER@$EDW_DEPLOY_HOST:$EDW_DEPLOY_DIR/.env
    ssh -q -t $EDW_DEPLOY_USER@$EDW_DEPLOY_HOST "cd $EDW_DEPLOY_DIR && { \
        echo >> .env ;\
        echo EDW_BUILD_VER=$tag >> .env ;\
        }"


    for proj in "${arr_docker_images[@]}"; do
        local partial_image_name=`_edw_full_docker_image -t\  $proj`
        local image_name=`_edw_full_docker_image -t $tag $proj`

        if [ $no_pull = false ]; then
            ssh -q -t $EDW_DEPLOY_USER@$EDW_DEPLOY_HOST "cd $EDW_DEPLOY_DIR && { \
                if [ -f current_tag ]; then \
                    if [ -f old_old_tag ]; then \
                        docker rmi ${partial_image_name}\`cat old_old_tag\` || true ;\
                    fi ;\
                    if [ -f old_tag ]; then \
                        cp old_tag old_old_tag ;\
                    fi ;\
                    cp current_tag old_tag ;\
                fi ;\
                docker pull $image_name ;\
                echo -n $tag > current_tag ;\
                }"
        fi
        _edw_bail_out_if_error
        # TODO
        # should apply some init/bare-init scripts here. add some option for bare, init, some other updates?
        # these are project specific? source something from proj.docker folder here?
        # execte r-init.sh scripts blindly?
        # right now just use with -s (no-start) and do this kind of stuff manually
    done

    if [ "$no_start" = false ]; then
        ssh -q -t $EDW_DEPLOY_USER@$EDW_DEPLOY_HOST "cd $EDW_DEPLOY_DIR &&\
            EDW_BUILD_VER=$EDW_BUILD_VER docker-compose up -d
            "
    fi

)

# TODO transform this into _caged and add command line options and help
_edw_up() {
    local foreground="$1"

    # Any option you give to this command will be interpreted as "run in foreground"
    # Leave empty to run in background
    if [ -z "$foreground" ]; then
        dettached='-d'
    else
        dettached=
    fi
    ssh -q -t $EDW_DEPLOY_USER@$EDW_DEPLOY_HOST "cd $EDW_DEPLOY_DIR && env \`xargs < .env\` docker-compose up $dettached"
}

_edw_stop() {
    ssh -q -t $EDW_DEPLOY_USER@$EDW_DEPLOY_HOST "cd $EDW_DEPLOY_DIR && env \`xargs < .env\` docker-compose stop"
}


## parse main script options 

while getopts ":he:" opt; do
    case "$opt" in
        e)
            g_env_file=$OPTARG
            ;;
        h)
            _edw_help
            exit 0
            ;;
        ?)
            echo "Invalid option: -$OPTARG" >&2
            _edw_help
            exit 1
            ;;
        :)
            echo "Option -$OPTARG requires an argument." >&2
            _edw_help
            exit 1
            ;;
    esac
done
shift $((OPTIND-1))

_edw_set_env $g_env_file

## Run command

com=$1
shift
case "$com" in
    build)
        _edw_build_caged "$@"
        ;;
    deploy)
        _edw_deploy_caged "$@"
        _edw_bail_out_if_error show_message
        ;;
    restore)
        echo "Not implemented"
        ;;
    up)
        _edw_up "$@"
        ;;
    stop)
        _edw_stop "$@"
        ;;
esac
